
-- 1. Top Selling Products
-- Query the top 10 products by total sales value.
-- Challenge: Include product name, total quantity sold, and total sales value.
SELECT products.product_id,
		products.product_name, 
       COUNT(products.product_id) AS product_count, 
       ROUND(SUM(oi.total_sales),2) AS total_sales
FROM order_items oi 
INNER JOIN products 
    ON products.product_id = oi.product_id
INNER JOIN orders
	ON orders.order_id = oi.order_id
GROUP BY products.product_id, products.product_name
ORDER BY SUM(oi.total_sales) desc
LIMIT 10;

-- 2. Revenue by Category
-- Calculate total revenue generated by each product category.
-- Challenge: Include the percentage contribution of each category to total revenue.

select p.category_id,
c.category_name,
round(cast(sum(oi.total_sales) as numeric),2) as total_sales,
round(cast((sum(oi.total_sales)/(select sum(total_sales) from order_items))*100 as numeric),2) as percentage_contribution
from order_items oi
inner join products p on p.product_id = oi.product_id
inner join orders o on o.order_id = oi.order_id
inner join category c on c.category_id = p.category_id
group by 1,2
order by 3 desc;

-- 3. Average Order Value (AOV)
-- Compute the average order value for each customer.
-- Challenge: Include only customers with more than 5 orders.

select o.customer_id,
		concat(c.first_name,' ',c.last_name) as full_name,count(*),
		round(avg(total_sales),2) as Average_order_value
		from orders o
left join customers c on o.customer_id = c.customer_id
left join order_items oi on oi.order_id = o.order_id
group by 1,2
having count(*)>5;

-- 4. Monthly Sales Trend
-- Query monthly total sales over the past year.
-- Challenge: Display the sales trend, grouping by month, return current_month sale, last month sale!

select year,month,total_sales as current_month_sales,lag(total_sales,1) over (order by 2,1) as previous_month_sales
from (select extract(month from order_date) as month,
extract (year from order_date) as year,
round(cast(sum(total_sales) as numeric),2) as total_sales
from orders o
inner join order_items oi
using(order_id)
where o.order_date >= current_date - Interval '1 year'
group by 1,2
order by 2,1);

-- 5. Customers with No Purchases
-- Find customers who have registered but never placed an order.
-- Challenge: List customer details and the time since their registration.

select * from orders o
right join customers c using (customer_id)
where order_id is Null;

-- 6. Least-Selling Categories by State
-- Identify the least-selling product category for each state.
-- Challenge: Include the total sales for that category within each state.

with cte as (
select round(sum(total_sales),2) as total_sales,
	c.state,
	ca.category_name,
	rank() over(partition by c.state ORDER BY SUM(oi.total_sales) ASC) as rank
from order_items oi
join products p on oi.product_id = p.product_id
join orders o on oi.order_id = o.order_id
join customers c on o.customer_id = c.customer_id
join category ca on ca.category_id = p.category_id
group by 2,3 
order by 2,4)
select state,category_name, total_sales from cte where rank = 1;


-- 7. Customer Lifetime Value (CLTV)
-- Calculate the total value of orders placed by each customer over their lifetime.
-- Challenge: Rank customers based on their CLTV.

select o.customer_id,round(sum(total_sales)::numeric, 2) as CLTV,
dense_rank() over(order by sum(total_sales) desc) as rank
from orders o
join customers c on c.customer_id = o.customer_id
join order_items oi on oi.order_id  = o.order_id
group by 1;

-- 8. Inventory Stock Alerts
-- Query products with stock levels below a certain threshold (e.g., less than 10 units).
-- Challenge: Include last restock date and warehouse information.

select i.inventory_id,p.product_id,p.product_name,i.warhouse_id,i.stock from inventory i
right join products p on p.product_id = i.product_id
where i.stock<10;

-- 10. Payment Success Rate 
-- Calculate the percentage of successful payments across all orders.
-- Challenge: Include breakdowns by payment status (e.g., failed, pending).

select payment_status,
count(*) as total_count,
count(*)::numeric/(select count(*) from payments)::numeric * 100 as percentage
from payments
group by 1;

-- 11. Top Performing Sellers
-- Find the top 5 sellers based on total sales value.
-- Challenge: Include both successful and failed orders, and display their percentage of successful orders.

select * from sellers;
select *  from orders;

with top_sellers as (select s.seller_id,s.seller_name,
	sum(oi.total_sales) as total_sales
from orders o 
join order_items oi on oi.order_id = o.order_id
join sellers s on s.seller_id = o.seller_id
group by 1,2
order by 3 desc
limit 5),
report as (select ts.seller_id,ts.seller_name,count(o.order_status) as total_count,o.order_status from top_sellers ts
join orders o on o.seller_id = ts.seller_id
where o.order_status in ('Completed','Cancelled')
group by 1,2,4)
select seller_id,seller_name,sum(case when order_status = 'Completed' then total_count else null end) as completion_count,
sum(case when order_status = 'Cancelled' then total_count else null end) as cancellation_count,
sum(case when order_status = 'Completed' then total_count else null end)/sum(total_count) *100 as success_percentage
from report
group by 1,2
order by 5 desc;

-- 12. Product Profit Margin
-- Calculate the profit margin for each product (difference between price and cost of goods sold).
-- Challenge: Rank products by their profit margin, showing highest to lowest.

select p.product_name,
		round(sum(oi.total_sales-(p.cogs*oi.quantity)),2) as profit,
		round(sum(oi.total_sales-(p.cogs*oi.quantity)),2)/sum(oi.total_sales)*100 as profit_margin,
		dense_rank() over( order by round(sum(oi.total_sales-(p.cogs*oi.quantity)),2)/sum(oi.total_sales)*100 desc) as rank
from products p 
join order_items oi on p.product_id = oi.product_id
group by 1;

-- 13. Most Returned Products
-- Query the top 10 products by the number of returns.
-- Challenge: Display the return rate as a percentage of total units sold for each product.

select * from sellers;
select * from orders;
select * from products;
select * from order_items;

SELECT 
	p.product_id,
	p.product_name,
	COUNT(*) AS total_unit_sold,
	count(case when o.order_status = 'Returned' then oi.order_id else Null end) as total_returns,
	ROUND(count(case when o.order_status = 'Returned' then oi.order_id else Null end)/count(*)::numeric,2)*100 as return_rate
from order_items as oi
join orders as o 
on oi.order_id = o.order_id
join products as p 
on p.product_id = oi.product_id
group by 1,2
having count(case when o.order_status = 'Returned' then oi.order_id else Null end)>5
order by 5 desc;

-- 14. Orders Pending Shipment
-- Find orders that have been paid but are still pending shipment.
-- Challenge: Include order details, payment date, and customer information.

select c.*,
	o.*,
	p.payment_date,
	p.payment_status,
	s.delivery_status
from orders o
join payments p on p.order_id = o.order_id
join shippings s on s.order_id  = o.order_id
join customers c on c.customer_id  = o.customer_id
where p.payment_status = 'Payment Successed' and s.delivery_status = 'Shipped';

-- 15. Inactive Sellers
-- Identify sellers who havenâ€™t made any sales in the last 6 months.
-- Challenge: Show the last sale date and total sales from those sellers.

with cte as (
select * FROM sellers where seller_id not in (select seller_id from orders where order_date >= current_date - interval '6 month' ))
select * from orders o
left join cte on o.seller_id  = cte.seller_id 
where cte.seller_id is not null;

-- 16. IDENTITY customers into returning or new
-- if the customer has done more than 5 return categorize them as returning otherwise new
-- Challenge: List customers id, name, total orders, total returns

select full_name,
	total_orders,
	total_returns,
	case when total_returns >5 then 'Returning' else 'New' end as category 
from (select c.customer_id,
	concat(left(c.first_name,1),'. ',c.last_name) as full_name,
	count(o.order_id) as total_orders,
	sum(case when o.order_status = 'Returned' then 1 else 0 end) as total_returns
from orders o 
left join customers c on c.customer_id = o.customer_id
group by 1,2);


-- 17. Top 5 Customers by Orders in Each State
-- Identify the top 5 customers with the highest number of orders for each state.
-- Challenge: Include the number of orders and total sales for each customer.

select * from (
select c.customer_id,concat(left(first_name,1),'. ',last_name) as full_name, c.state, count(o.order_id), sum(oi.total_sales),
dense_rank() over(partition by c.state order by count(o.order_id) desc) as rank
from orders o
left join order_items oi on oi.order_id = o.order_id
left join customers c on o.customer_id = c.customer_id
group by 1,2,3)
where rank<=5;

-- 20. Top 10 product with highest decreasing revenue ratio compare to last year(2022) and current_year(2023)
-- Challenge: Return product_id, product_name, category_name, 2022 revenue and 2023 revenue decrease ratio 
-- at end Round the result
-- Note: Decrease ratio = cr-ls/ls* 100 (cs = current_year ls=last_year)
WITH last_year AS (
    SELECT 
        p.product_id,
        p.product_name,
        c.category_name,
        SUM(oi.total_sales) AS total_revenue
    FROM orders AS o
    JOIN order_items AS oi ON o.order_id = oi.order_id
    JOIN products AS p ON oi.product_id = p.product_id
    JOIN category AS c ON p.category_id = c.category_id
    WHERE EXTRACT(YEAR FROM o.order_date) = 2022
    GROUP BY p.product_id, p.product_name, c.category_name
),
current_year AS (
    SELECT 
        p.product_id,
        p.product_name,
        c.category_name,
        SUM(oi.total_sales) AS total_revenue
    FROM orders AS o
    JOIN order_items AS oi ON o.order_id = oi.order_id
    JOIN products AS p ON oi.product_id = p.product_id
    JOIN category AS c ON p.category_id = c.category_id
    WHERE EXTRACT(YEAR FROM o.order_date) = 2023
    GROUP BY p.product_id, p.product_name, c.category_name
)
SELECT 
    cy.product_id,
    cy.product_name,
    cy.category_name,
    ROUND(ly.total_revenue::numeric, 2) AS last_year_revenue,
    ROUND(cy.total_revenue::numeric, 2) AS current_year_revenue,
    ROUND((cy.total_revenue - ly.total_revenue) / NULLIF(ly.total_revenue, 0) * 100, 2) AS revenue_dec_ratio
FROM last_year ly
JOIN current_year cy ON ly.product_id = cy.product_id
WHERE ly.total_revenue > cy.total_revenue
ORDER BY revenue_dec_ratio DESC
LIMIT 10;



-- Final Task
-- -- Store Procedure
-- create a function as soon as the product is sold the the same quantity should reduced from inventory table
-- after adding any sales records it should update the stock in the inventory table based on the product and qty purchased
